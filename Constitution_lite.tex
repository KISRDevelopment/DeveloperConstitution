% Do not edit this f{}ile unless you know what are doing ;)
% The following line def{}ines the type of printing paper and the size of the font along with the type of the file "article"
% It's possible to choose different document types check out the official latex documentations http://tobi.oetiker.ch/lshort/lshort.pdf
\documentclass[titlepage,a4paper,11pt]{article}

\usepackage[T1]{fontenc}

\usepackage[margin=1.0in]{geometry}

%defining authors
\author{Abdulrahman Alotaibi and Abdulaziz Alsaffar}
\title{KISR Development Constitution}

\begin{document}
\maketitle
\pagebreak
\thispagestyle{empty}
\tableofcontents
\pagebreak
\pagestyle{plain}
\setcounter{page}{1}
\pagenumbering{arabic}
\newpage

\section{Introduction}
This constitution aims to def{}ine the work f{}low of any development projects undertaken in the future. We hope that it will make a dif{}ference to the way you develop software. Universities have their rules of teaching, and most of them want to make students understand basic algorithms and code syntax. This paper is a guide for real world development geared towards producing programs that work for ever. This paper emphasises development projects undertaken by a whole team of developers, not a single coder that is sitting in a basement somewhere.

%Most of the tools in the next few sections can be divided into two main categories development tools and system level tools. The development tools are those that you need to while developing a program or application e.g. . System level tools are elements that you need to do a specif{}ic job e.g. web servers or databases. %Not sure about the clarity of that last sentence.
In the following sections we will discuss several tools, most of them built on top of Unix like operating systems. The following sections will put emphasis on the importance of using \textbf{Free} and \textbf{Open Source} software. We admit that there is occasionally a steep learning curve, but after passing it things will make a lot more sense, and you will be a faster, more productive developer.

\section{Virtual Machine}
Some projects may require you to work in a specif{}ic environment. You might need to develop and run your application in specif{}ic operating systems, using specif{}ic tools, set up in a very specif{}ic way (e.g. a webGIS service running of{}f a GeoServer with an Oracle Spatial database).

One way to do this is to have a whole new physical development machine for every project type that you work on. As you can imagine this can get very expensive and wasteful very fast. Another way would be to force development to adhere to one specif{}ic environment and setup but this is very limiting to a developer.

With a virtual machine (VM) you can run an emulation of an entire computer on your host system. This allows you to create very specif{}ic development environments where you have the OS that you need, loaded only with the very specif{}ic tools and software that you need for the project that you are currently working on. You can take snapshots of your VM, mess around with it, and if anything goes wrong, you can scrap it and reload it from the snapshot. When you're done and your application has been moved to production, you just scrap the VM.

\section{Command Line Interface}
There are many many many Command Line Interface (CLI) tools out there. Some universities dedicate months to teaching CS and CE students how to use them ef{}fectively. They are extremely useful for helping you setup, navigate, and manipulate your development environment.
We recommend using the CLI as much as possible. It will make you faster and more ef{}f{}icient. %and as a bonus you feel like you're commanding a spaceship or like you're a supercool hax0r!! %this is what happens when I edit things at 3:30am


\section{Package Managers}
At certain points in the development process you will f{}ind yourself adding and removing a huge number of packages, libraries and entire applications. A package manager is a collection of software tools that makes the process of installing, upgrading, conf{}iguring and removing all this software from your operating system automated and ef{}f{}icient.

This is a concept that has gained signif{}icant traction over the last few years with the advent of mobile computing. With a phone or a tablet, you don't want to have to hunt around for the software you need to install and you don't want to have to manually upgrade all your applications. Instead you have a package management system  with a GUI (e.g. the Play Store).

\section{Version Control Systems}
An absolutely critical part of any group development setup is version and revision control. If you setup a repository of f{}iles for your project and you have multiple people working on these f{}iles then it becomes absolutely critical to track the changes that are taking place. You need to know what was changed, when it was changed and who changed it. Luckily there are existing version control systems (VCS) that can manage all of this for you.

\section{Integrated Development Environments}
IDEs are your best friend. Any time you adopt a new language or framework to work with one of your f{}irst priorities should be to f{}ind an IDE that you love. It will be your home for the life of the project.

Like the name suggests, an IDE creates a convenient environment in which you can develop your software/application. You'll have a complete view of your project; its directories, packages, and libraries; and the many f{}iles that make it up. IDEs give you the ability to edit, develop, test, analyse, run and debug your project all in one convenient place. They are also often packed full of tonnes of tools and features designed specif{}ically to make your job easier and more convenient.

\section{Databases}
At the heart of it a database is simply an organised collection of data. Unless you're developing very small scale applications, you will absolutely need to have the tools necessary to store and manage your data in a database. Most databases run as a server on the system and you can access them by using the CLI  or you can install a GUI (graphical user interface) to interact with the database. 

\section{Webserver}
Any kind of web application development (and this accounts for most modern development) requires that you have a web server to develop and eventually launch your application. The web server is the tool that allows you to deliver web content by handling requests from clients. It also allows you receive content from clients. In short,  it is the tool that will handle communications with your users. Whether you are testing your application or deploying it, you need to have a web server.

\section{Testing Framework}
Testing, retesting, testing one more time and testing again. This is something that we're all familiar with when it comes to programming. However, when it comes to large scale development testing can quickly become a massively time consuming, repetitive task. Luckily, you don't have to deal with that kind of tedium. There are many language dependant testing frameworks, separate from the software you're developing, that will let you automate your testing.

\section{Documentation and Reporting}
It is vital to document your code, not just so other developers can quickly understand what you're trying to accomplish, but also so you can understand your own code as you return to it. There are tools and protocols available that will allow you to quickly generate documentation in many formats from the comments you add during coding.

You will also be generating a lot of reports after completing sections of a project. Rather than waste time on formatting and layout, there are tools that allow you to focus purely on the content. This document was written using \LaTeX and it's a good example of reporting software.


\section{Logging Software and Issue Tracking Software}
You will need to keep track of how your application is being used, both in development and production. You need to have a way to quickly f{}ind, reproduce and resolve errors that are encountered by users. You also want to be able to optimise the way your application runs. Logging and tracking software packages give you an interface to this information. This will give you a better understanding of how your software works and how you can improve and evolve it.

\end{document}
